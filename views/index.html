<!DOCTYPE html>
<html lang="en">

<head>



  <title>Hola</title>


  <style>
    html,
    body {
      overflow: hidden;
      margin: 0;
      width: 100%;
      height: 100%;

    }

    .player {
      position: absolute;
      bottom: 1rem;
      width: 100%;

    }

    .timeControl {
      position: absolute;
      bottom: 0;
      padding: 1rem;


    }

    .timeControl>input {
      width: 50px;
    }
  </style>
</head>

<body>


  <!-- <audio class="player" controls>
    <source src="music/hello.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio> -->

  <img id="asteroid" src="sprites/asteroid.png" style="display:none" />

  <div class="timeControl">
    <input id="travelTo" placeholder="1000" />
    <button onclick="travelTo( travelTo.value || 1000)">Go</button>

  </div>

  <canvas id="myCanvas"></canvas>

  <script>


    const tEndIntro = 22700
    const tStartChangeColor = 46600
    const tEndChangeColor = 54500

    const tStartSecondaryLyrics = tStartChangeColor
    const tEndSecondaryLyrics = 54600





    const onKeyDown = (e) => {
      // console.log(e)
      switch (e.code) {
        case 'Digit1':
          travelTo(tEndIntro)
          break;
        case 'Digit2':
          travelTo(tStartChangeColor)
          break;
        case 'Space':
          console.log('Space')
          nextWord()
          break;
        case 'KeyB':
          farBackStars = !farBackStars
          break;
        case 'KeyM':
          console.log('M')
          lyrics.position.noise -= 0.5
          break;
        case 'KeyN':
          console.log('N')
          lyrics.position.noise += 0.5
          break;
        case 'KeyT':
          console.log(timeSong)
          break;
        case 'KeyQ':
          console.log('Q')
          sizeFrontMax++
          break;
        case 'KeyS':
          console.log('S')
          start()
          break;

        case 'KeyC':
          starsShape = (starsShape + 1) % 3
          console.log(starsShape)
          break

        case 'KeyD':
          DEBUG = !DEBUG
          break
      }
    }

    document.addEventListener("keydown", onKeyDown);



    var DEBUG = true
    var N, speed0, speed1, speed, startTime, timePrev, timeNow, timeSong, dt, canvas, ctx
    var songStarted = false
    let farBackStars = false




    const SHOWSQUARES = 0
    const SHOWCIRCLES = 1
    const SHOWIMAGE = 2


    let starsShape = 0



    var starsFront = [];
    var starsBack = [];
    var starsFarBack = [];





    class Color {
      constructor(r, g, b) {
        this.r = r
        this.g = g
        this.b = b

      }

      plus(col) {
        return new Color(this.r + col.r, this.g + col.g, this.b + col.b)
      }

      minus(col) {
        return new Color(this.r - col.r, this.g - col.g, this.b - col.b)
      }

      divided(value) {
        return new Color(this.r / value, this.g / value, this.b / value)
      }

      multiplied(value) {
        return new Color(this.r * value, this.g * value, this.b * value)
      }



      increment(i) {
        this.r += i
        this.g += i
        this.b += i

      }



      get rgb() {
        return `rgb(${this.r}, ${this.g}, ${this.b})`
      }
    }



    function start() {
      if (music.paused) {
        if (music.currentTime == 0) {
          music.currentTime += 0.096

          speed = speed0
        }
        startTime = performance.now() - (timeSong || 0)

        music.play().then(songStarted = true);
      }
      else {
        music.pause()
        songStarted = false
      }






    }

    function init() {
      console.log('init')
      N = 50
      timePrev = 0




      music = new Audio('music/hello.mp3');
      img = document.getElementById("asteroid")


      initCanvas()


      initStars()

      window.requestAnimationFrame(() => { update(); render() })
    }



    // INITATORS

    function initCanvas() {
      canvas = document.querySelector("canvas");
      canvas.width = document.body.clientWidth;
      canvas.height = document.body.clientHeight;
      canvas.addEventListener('click', start)
      ctx = canvas.getContext("2d");
    }

    function initStars() {
      for (var i = 0; i < N; ++i) {

        starsFront.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          z: 0.5 + Math.random() * 2,
        });
      }
      for (var i = 0; i < N; ++i) {
        starsBack.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          z: 4 + Math.random() * 1
        });
      }
      for (var i = 0; i < 8000; ++i) {
        starsFarBack.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          z: 80 + Math.random() * 1
        });
      }

    }


    // UPDATORS
    function updateStarsFront(dt) {
      for (star in starsFront) {
        var star = starsFront[star];

        const constantHorizontalSpeed = speeds.horizontal.speed / star.z
        const constantVerticalSpeed = speeds.vertical.speed / star.z

        oscillatorySpeedX = speeds.radius.speed * Math.cos(speeds.angular.speed * timeNow / 1000)
        oscillatorySpeedY = speeds.radius.speed * Math.sin(speeds.angular.speed * timeNow / 1000)

        star.x += constantHorizontalSpeed * dt + oscillatorySpeedX
        star.y += constantVerticalSpeed * dt + oscillatorySpeedY

        if (star.y > canvas.height) { star.y = star.y % canvas.height } else if (star.y < 0) { star.y = canvas.height + (star.y % canvas.height) }
        if (star.x > canvas.width) { star.x = star.x % canvas.width } else if (star.x < 0) { star.x = canvas.width + (star.x % canvas.width) }

      }
    }

    function updateStarsBack(dt) {
      for (star in starsBack) {
        var star = starsBack[star];

        const constantHorizontalSpeed = speeds.horizontal.speed / star.z
        const constantVerticalSpeed = speeds.vertical.speed / star.z

        oscillatorySpeedX = speeds.radius.speed * Math.cos(speeds.angular.speed * timeNow / 1000)
        oscillatorySpeedY = speeds.radius.speed * Math.sin(speeds.angular.speed * timeNow / 1000)

        star.x += constantHorizontalSpeed * dt + oscillatorySpeedX
        star.y += constantVerticalSpeed * dt + oscillatorySpeedY


        if (star.y > canvas.height) { star.y = star.y % canvas.height } else if (star.y < 0) { star.y = canvas.height + (star.y % canvas.height) }
        if (star.x > canvas.width) { star.x = star.x % canvas.width } else if (star.x < 0) { star.x = canvas.width + (star.x % canvas.width) }
      }
    }


    function updateStarsFarBack(dt) {
      for (star in starsFarBack) {
        var star = starsFarBack[star];
        const starSpeed = speeds.vertical.speed / star.z

        star.y += starSpeed * 10 * dt
        if (star.y > canvas.height) { star.y = star.y % canvas.height } else if (star.y < 0) { star.y = canvas.height + (star.y % canvas.height) }
        if (star.x > canvas.width) { star.x = star.x % canvas.width } else if (star.x < 0) { star.x = canvas.width + (star.x % canvas.width) }
      }
    }

    var sizeFrontMax = 18
    var sizeBackMax = 84

    const cvw = document.body.clientWidth
    const cvh = document.body.clientHeight

    const secondaryLyrics = {
      speed: -3,
      content: [
        {
          text: 'Ven conmigo',
          alpha: 1,
          tStart: tStartSecondaryLyrics,
          position: { x: cvw / 5, y: cvh }
        },
        {
          text: 'Ven conmigo',
          alpha: 1,
          tStart: 48600,
          position: { x: cvw / 2, y: cvh }
        },
        {
          text: 'Ven conmigo',
          alpha: 1,
          tStart: 50500,
          position: { x: 4 * cvw / 5, y: cvh }
        },
        {
          text: 'Al universo',
          alpha: 1,
          tStart: 52600,
          position: { x: cvw / 2, y: cvh }

        },
        {
          text: 'ven conmigo',
          alpha: 1,
          tStart: 53600,
          position: { x: cvw / 2, y: cvh }

        },
      ]
    }

    const lyrics = {
      isFadingOut: false,
      alpha: 1,
      position: { x: 0, y: 0, noise: 5 },

      content: [
        'Fly',
        'In the universe',
        'I want to',
        'Fly',
        'There is no war',
        'There is no',
        'Crime',
        'Please come with me',
        'And take my',
        'Hand',
        'Sal ahora mismo y déjalo',
        'Vente al universo conmigo',
        'Escápate y olvídalo',
        'Vente al universo conmigo',
        'Prepárate y vámonos',
        'Vente al universo conmigo',
        'Quiero volar'
      ]
    }


    var keyPressedMap = {}; // You could also use an array
    onkeydown = onkeyup = function (e) {
      e = e || event; // to deal with IE
      keyPressedMap[e.keyCode] = e.type == 'keydown';
      /* insert conditional here */
    }

    var speeds = {
      vertical: {
        speed: - 0.01,
        from: - 2.8,
        to: - 0.01
      },
      horizontal: {
        speed: 0.01 * 0
      },
      radius: {
        speed: 0.1 * 0
      },
      angular: {
        speed: 0.5 * 0
      }
    }
    var oscillatorySpeedX = 0
    var oscillatorySpeedY = 0

    var colors = {
      background: {
        color: new Color(0, 0, 0),
        from: new Color(0, 0, 0),
        to: new Color(255, 255, 255),
      },
      starsFront: {
        color: new Color(255, 255, 255),
        from: new Color(255, 255, 255),
        to: new Color(0, 0, 0),

      },
      starsBack: {
        color: new Color(220, 220, 220),
        from: new Color(220, 220, 220),
        to: new Color(35, 35, 35),

      }
    }

    let currentVerseIndex = 0
    let currentWordIndex = 0
    let currentVerseList = lyrics.content[0].split(' ')
    let currentWord = currentVerseList[0]
    let currentTextBuffer = ''
    let toWrite = ''

    function travelTo(toTime_ms) {
      const toTime = toTime_ms / 1000
      music.currentTime = toTime
      startTime = timeNow - toTime_ms





    }
    function nextWord() {
      if (currentWordIndex > currentVerseList.length - 1) {
        currentWordIndex = 0
        currentVerseIndex++
        currentVerseList = lyrics.content[currentVerseIndex].split(' ')
        currentTextBuffer = ''


      }
      currentWord = currentVerseList[currentWordIndex]
      currentTextBuffer += currentWord + (currentWordIndex == currentVerseList.length - 1 ? '' : ' ')
      currentWordIndex++


    }

    // DRAWERS
    function drawDebug() {

      const what =
        `dt:
map :
music.currentTime : 
timeSong :
startTime:
timeNow:
horizontalSpeed:
verticalSpeed:
radiusSpeed:
angularSpeed:
oscillatorySpeedX:
oscillatorySpeedY:
lyrics.noise:
`
      const value =
        `${dt.toFixed(2)}
${JSON.stringify(keyPressedMap)}
${music.currentTime.toFixed(2)}
${(timeSong / 1000 || 0).toFixed(2)}
${(startTime || 0).toFixed(0)}
${timeNow.toFixed(0)}
${speeds.horizontal.speed.toFixed(2)}
${speeds.vertical.speed.toFixed(2)}
${speeds.radius.speed.toFixed(2)}
${speeds.angular.speed.toFixed(2)}
${oscillatorySpeedX.toFixed(2)}
${oscillatorySpeedY.toFixed(2)}
${lyrics.position.noise}



`





      const lines = what.split('\n');
      const lines2 = value.split('\n');

      const Nlines = lines.length
      const lineHeight = 16
      const lenghtWhat = 120
      const lenghtValue = 60

      ctx.fillStyle = "black";

      ctx.fillRect(0, 0, lenghtWhat, Nlines * lineHeight)

      ctx.fillRect(lenghtWhat, 0, lenghtValue, Nlines * lineHeight)
      ctx.fillStyle = "cyan";

      ctx.font = "10px courier";
      ctx.textAlign = "start"



      for (var i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], 5, 10 + (i * lineHeight));

        ctx.fillText(lines2[i], lenghtWhat, 10 + (i * lineHeight));
      }

      ctx.fillStyle = 'red'
      ctx.fillRect(canvas.width / 2, canvas.height / 2 + dt, 1, 1)
    }




    function drawLyrics() {


      ctx.fillStyle = "rgb(255,255,0 ," + lyrics.alpha + ")";

      ctx.font = "70px arial";
      ctx.textAlign = "start"

      let textSize = ctx.measureText(lyrics.content[currentVerseIndex]).width

      ctx.fillText(currentTextBuffer, lyrics.position.x - textSize / 2, lyrics.position.y);

    }

    function drawSecondaryLyrics() {

      if (timeSong >= tStartSecondaryLyrics && timeSong <= tEndSecondaryLyrics) {
        ctx.font = "30px arial";
        ctx.textAlign = "center"
        for (i in secondaryLyrics.content) {
          const lyric = secondaryLyrics.content[i]
          if (timeSong >= lyric.tStart) {
            ctx.fillStyle = "rgb(255,255,0 ," + lyric.alpha + ")";
            ctx.fillText(lyric.text, lyric.position.x, lyric.position.y);
  

          }

        }


      }

    }

    function drawStarsFront(stars) {
      ctx.fillStyle = colors.starsFront.color.rgb;
      for (star in stars) {

        ctx.fillStyle = colors.starsFront.color.rgb;


        var star = stars[star];

        const size = sizeFrontMax / star.z


        switch (starsShape) {
          case SHOWSQUARES:

            ctx.fillRect(star.x - size / 2, star.y - size / 2, size, size);

            break
          case SHOWCIRCLES:
            drawCircle(star.x, star.y, size / 2, colors.starsFront.color.rgb)
            break
          case SHOWIMAGE:

            ctx.fillRect(star.x - size / 2, star.y - size / 2, size, size);

            ctx.drawImage(img, star.x - size / 2, star.y - size / 2, size, size);
            break
        }
      }
    }

    function drawCircle(x, y, radius, color) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawStarsBack(stars) {
      ctx.fillStyle = colors.starsBack.color.rgb
      for (star in stars) {
        var star = stars[star];
        const size = sizeBackMax / star.z

        switch (starsShape) {
          case SHOWSQUARES:
            ctx.fillRect(star.x - size / 2, star.y - size / 2, size, size);
            break
          case SHOWCIRCLES:
            drawCircle(star.x, star.y, size / 2, colors.starsFront.color.rgb)
            break
          case SHOWIMAGE:
            drawCircle(star.x, star.y, size / 2, colors.starsFront.color.rgb)
            break
        }

      }
    }

    function drawStarsFarBack(stars) {
      ctx.fillStyle = colors.starsFront.color.rgb
      for (star in stars) {
        var star = stars[star];
        ctx.fillRect(star.x, star.y, 0.3, 0.3);

      }
    }

    function drawBackground() {
      ctx.fillStyle = colors.background.color.rgb;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }


    function updateSpeedTransition(speeds, start, end) {
      const acceleration = (speeds.to - speeds.from) / (end - start)
      speeds.speed = speeds.from + (acceleration * (Math.min(Math.max(parseFloat(timeSong), start), end) - start))

    }

    function updateColorTransition(colors, start, end) {
      const colorSpeed = colors.to.minus(colors.from).divided(end - start)
      colors.color = colors.from.plus(colorSpeed.multiplied(Math.min(Math.max(parseFloat(timeSong), start), end) - start))

    }

    function updateSpeedsKeyPressed() {

      const ctrlPressed = keyPressedMap[17] || false
      const leftAltPressed = keyPressedMap[18] || false
      const spacePressed = keyPressedMap[32] || false

      const leftPressed = keyPressedMap[37] || false
      const upPressed = keyPressedMap[38] || false
      const rightPressed = keyPressedMap[39] || false
      const downPressed = keyPressedMap[40] || false

      const boost = 0.005

      if (!ctrlPressed) {

        speeds.vertical.speed += boost * (downPressed - upPressed)
        speeds.horizontal.speed += boost * (rightPressed - leftPressed)

      } else {
        const radiusBoost = 0.05
        const angularSpeedBoost = 0.05

        speeds.radius.speed += radiusBoost * (downPressed - upPressed)
        speeds.angular.speed += angularSpeedBoost * (rightPressed - leftPressed)
      }

      if (spacePressed) {
        lyrics.isFadingOut = true
        lyrics.alpha = 1
      }







    }

    function updateLyrics() {

      if (lyrics.isFadingOut) {
        lyrics.alpha -= 0.01
        if (lyrics.alpha <= 0) lyrics.isFadingOut = false
      }


      lyrics.position.x = canvas.width / 2 + Math.cos(timeNow / 1000) * 20
      lyrics.position.y = canvas.height / 2 + Math.sin(timeNow / 1000) * 10


    }

    function updateSecondaryLyrics() {
      
      if (timeSong >= tStartSecondaryLyrics && timeSong <= tEndSecondaryLyrics) {
        for (i in secondaryLyrics.content) {
          const lyric = secondaryLyrics.content[i]
          if (timeSong >= lyric.tStart) {

            lyric.position.y += secondaryLyrics.speed
            lyric.alpha -= 0.01
          }
        }
      }
    }


    //UPDATE
    function update() {

      timeNow = performance.now()
      dt = timeNow - timePrev

      timePrev = timeNow

      updateSpeedsKeyPressed()



      if (songStarted) {
        timeSong = timeNow - startTime

        // 1 transition, reduce speed
        updateSpeedTransition(speeds.vertical, 0, tEndIntro)

        // 2 transition, colors  inverted
        updateColorTransition(colors.background, tStartChangeColor, tEndChangeColor)
        updateColorTransition(colors.starsFront, tStartChangeColor, tEndChangeColor)
        updateColorTransition(colors.starsBack, tStartChangeColor, tEndChangeColor)

        //ven conmigo


      }



      updateLyrics()
      updateSecondaryLyrics()

      if (farBackStars)
        updateStarsFarBack(dt)
      updateStarsBack(dt)
      updateStarsFront(dt)

    }

    //RENDER
    function render() {

      drawBackground()
      if (farBackStars) drawStarsFarBack(starsFarBack)
      drawStarsBack(starsBack)


      drawLyrics()



      drawStarsFront(starsFront)


      drawSecondaryLyrics()





      if (DEBUG) {
        drawDebug()
      }





      window.requestAnimationFrame(() => { update(); render() });
    }






    function mainLoop() {

      update()
      render()

    }



    init()


  </script>


</body>

</html>